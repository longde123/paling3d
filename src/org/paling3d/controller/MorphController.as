package org.paling3d.controller{	import org.paling3d.geom.Point3D;	import org.paling3d.geom.Vertex; 	import org.paling3d.objects.TriangleMesh3D;	import org.paling3d.primitives.Geometry;	import org.paling3d.utils.log.PaperLogger;
	 
		/**	 * The MorphController class controls a mesh's vertices by applying a morph.	 * 	 * Each possible mesh that can be blended (a morph target) must be specified.	 * Each morph target is assigned a blend weight. The result is obtained via two methods :	 * 	 * <ol>	 * <li>NORMALIZED  (Target1, Target2, ...)*(w1, w2, ...) = (1-w1-w2-...)*BaseMesh + w1*Target1 + w2*Target2 + ...</li>	 * <li>RELATIVE    (Target1, Target2, ...) + (w1, w2, ...) = BaseMesh + w1*Target1 + w2*Target2 + ...</li>	 * </ol>	 * 	 * @author Tim Knip / floorplanner.com	 */	public class MorphController implements IObjectController	{		/** */		public var active :Boolean;				/** */		public var target :TriangleMesh3D;				/** */		public var targets :Array;				/** */		public var weights :Array;				/** */		public var normalized :Boolean;				/** */		private var cached :Array;				/**		 * Constructor.		 */ 		public function MorphController(target:TriangleMesh3D, normalized:Boolean=true)		{			this.target = target;			this.active = true;			this.targets = new Array();			this.normalized = normalized;			this.weights = new Array();			this.cached = new Array(); 					var v :Vertex;			//= target.geometry.vertexes;			for(var i:int=0;i<target.geometry.vertexes.length;i++)			{				v = target.geometry.vertexes[i];								cached[i] = v.clone();								i++							}		}				/**		 * 		 */		public function addMorphTarget(mesh:TriangleMesh3D, weight:Number):void		{		 	if(mesh.geometry.vertexes.length != this.target.geometry.vertexes.length)			{				PaperLogger.warning("Invalid morph target! " +					"Number of specified vertices (" + mesh.geometry.vertexes.length + ")" +					" not equal to number of base vertices (" +					+this.target.geometry.vertexes.length + ").");				return;			} 						this.targets.push(mesh);			this.weights.push(weight);		}				/**		 * 		 */ 		public function update():void		{			var orig :Geometry = this.target.geometry;			var cached :Array = this.cached;			var mesh :TriangleMesh3D;			var c :Point3D, v :Point3D, t :Point3D;			var num :int = cached.length;			var totalWeight :Number = 0;			var restWeight :Number, weight :Number;			var i :int, j :int;						if(!this.active)			{				return;			}						if(normalized)			{				for(i = 0; i < weights.length; i++)				{					totalWeight += weights[i];				}				restWeight = 1 - totalWeight;			}						for(i = 0; i < num; i++)			{				v = orig.vertexes[i].p;  //话说这里 还有个 loop 我要调				c = cached[i].p;								v.x = normalized ? restWeight * c.x : c.x;				v.y = normalized ? restWeight * c.y : c.y;				v.z = normalized ? restWeight * c.z : c.z;								for(j = 0; j < targets.length; j++)				{					mesh = targets[j];					t = mesh.geometry.vertexes[i].p;  //next 这里是不对的 我插啊					weight = weights[j];										v.x += weight * t.x;					v.y += weight * t.y;					v.z += weight * t.z;				}								 			}		}	}}